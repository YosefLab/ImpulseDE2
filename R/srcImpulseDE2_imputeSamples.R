#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
#+++++++++++++++++++++++++     Impute Samples    ++++++++++++++++++++++++++++++#
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#

#' Compute value of impulse function given parameters.
#' 
#' 
#' @seealso Called by \code{imputeSamples}.
#' 
#' @param vecTheta (vector number of parameters) Numerical vector of impulse 
#'    parameters with the order beta, h0, h1, h2, t1, t2.
#' @param vecTimepoints (vector number vecTimepoints) 
#'    Observed vecTimepoints, numeric.
#' 
#' @return vecY (vec number of vecTimepoints) 
#'    Model expression values of given gene for time points
#' @export
#' 
evaluateImpulseModel <- function(vecTheta,vecTimepoints){
  beta = vecTheta[1]
  h0 = vecTheta[2]
  h1 = vecTheta[3]
  h2 = vecTheta[4]
  t1 = vecTheta[5]
  t2 = vecTheta[6]
  vecY = unlist(lapply(vecTimepoints, function(x) {(1/h1) * 
      (h0 + (h1-h0) * (1/(1+exp(-beta*(x-t1))))) *
      (h2 + (h1-h2) * (1/(1+exp(beta*(x-t2)))))}))
  
  return(vecY)
}

#' Impute Samples in data set
#' 
#' Given an inferred impulse model, samples at a given time point are inferred.
#' This is an auxillary method called by the user. This funcion operates
#' on temporary data generated by ImpulseDE2 which are written to .RData by 
#' ImpulseDE2. All relevant data are communicated to this function through
#' these .RData files. Alternatively, the user can supply a model matrix of the
#' format of ImpulseDE2 output as input.
#' Give either case condition or control name to impute based on the respective
#' model if ImpulseDE2 was run in case-control mode. Give both to impute
#' based on the null model fit to the combined data.
#' 
#' @seealso Auxillary method not called during ImpulseDE2 running.
#' Called separately by user.
#' 
#' @param dirTemp: (str) Directory in which ImpulseDE2 wrote temporary files.
#' @param vecTPtoImpute: (numeric vector length time points to impute)
#'    Time points to be imputed by impulse model.
#' @param strCaseName: (str) Name of case condition. Do not give if
#'    want to impute based on control model only.
#' @param strCtrlName: (str) Name of control condition.  Do not give if
#'    want to impute based on case model only.
#' @ param matModel: (numeric matrix genes x model entries) [Default NULL]
#'    Override reading of files from directory, use this model matrix if given.
#' 
#' @return matImputed: (numeric matrix genes x imputed samples)
#'    Imputed values.
#' 
#' @export

imputeSamples <- function(dirTemp,
  vecTPtoImpute,
  strCaseName,
  strCtrlName,
  matModel=NULL ){
  
  if(is.null(matModel)){
    # 1) Load temporary data
    # Go to temporary directory
    tryCatch({
      setwd(dirTemp)
    }, error=function(strErrorMsg){
      stop(strErrorMsg)
    })
    load("ImpulseDE2_matCountDataProc.RData")
    load("ImpulseDE2_dfAnnotationProc.RData")
    load("ImpulseDE2_dfImpulseResults.RData")
    load("ImpulseDE2_vecDEGenes.RData")
    load("ImpulseDE2_lsImpulseFits.RData")
    load("ImpulseDE2_matSizeFactors.RData")
    
    # 2) Check input:
    if(any(!is.numeric(vecTPtoImpute) | is.na(vecTPtoImpute) | !is.finite(vecTPtoImpute))){
      stop("Time points to be imputed in vecTPtoImpute are not all numeric.")
    }
    if(is.null(strCaseName) & is.null(strCtrlName)){
      stop("Indicate which model to use for imputation through strCaseName and strCtrlName.")
    }
    # Check that time points ot be imputed are within range from
    # which model was built.
    vecTPData <- as.numeric(as.vector(dfAnnotationProc[
      dfAnnotationProc$Condition==strCaseName | dfAnnotationProc$Condition==strCtrlName]$Time))
    scaMinTPData <- min(vecTPData)
    scaMaxTPData <- max(vecTPData)
    if(any(vecTPtoImpute<scaMinTPData | vecTPtoImpute>scaMaxTPData)){
      warning(paste0("Some time points to be imputed lie outside the range on which the models were build: ",
        scaMinTPData, " to ", scaMaxTPData))
    }
    
    # Define model based on which imputation is to be done:
    if(!is.null(strCaseName) | is.null(strCtrlName)){
      matImputationModel <- lsImpulseFits$parameters_case
    } else if(is.null(strCaseName) | !is.null(strCtrlName)){
      matImputationModel <- lsImpulseFits$parameters_control
    } else if(!is.null(strCaseName) | !is.null(strCtrlName)){
      matImputationModel <- lsImpulseFits$parameters_combined
    } # Remaining case caught above in input control.
  } else {
    matImputationModel <- matModel
    print(paste0("WARNING: Make sure time points to be imputed are ",
      "within range on which model was trained"))
  }
  
  # 3) Impute time points
  lsImputed <- apply(matImputationModel, 1, function(genemodel){
    evaluateImpulseModel( vecTheta=as.numeric(as.vector(genemodel[1:6])), 
      vecTimepoints=vecTPtoImpute )
  })
  if(length(vecTPtoImpute)==1){
    matImputed <- matrix(as.vector(lsImputed), 
      nrow=length(lsImputed), ncol=1, byrow=FALSE)
  } else {
    matImputed <- do.call(rbind, lsImputed)
  }
  rownames(matImputed) <- names(lsImputed)
  
  return(matImputed)
}

#' Plots the imputed data and impulse fits to pdf
#' 
#' Plots the imputed data and impulse fits to pdf
#' 
#' @seealso Called by \code{runImputation}.
#' 
#' @param vecGeneIDs (string vector) Gene names to be plotted,
#      must be rownames of matCountDataProc
#' @param matCountDataProc: (matrix genes x samples)
#'    Count data: Reduced version of \code{matCountData}. 
#'    For internal use.
#' @param matTranslationFactors: (numeric matrix genes x samples) 
#'    Model scaling factors for each observation which take
#'    longitudinal time series mean within a gene into account 
#'    (translation factors). Computed based based on all samples.
#' @param matSizeFactors: (numeric matrix genes x samples) 
#'    Model scaling factors for each observation which take
#'    sequencing depth into account (size factors). One size
#'    factor per sample - rows of this matrix are equal.
#' @param dfAnnotationProc: (Table) Processed annotation table. 
#'    Lists co-variables of samples: 
#'    Sample, Condition, Time (numeric), TimeCateg (str)
#'    (and LongitudinalSeries). For internal use.
#' @param lsImpulseFits (list length 2 or 6) List of matrices which
#'    contain parameter fits and model values for given time course for the
#'    case condition (and control and combined if control is present).
#'    Each parameter matrix is called parameter_'condition' and has the form
#'    (genes x [beta, h0, h1, h2, t1, t2, logL_H1, converge_H1, mu, logL_H0, 
#'    ) where beta to t2 are parameters of the impulse
#'    model, mu is the single parameter of the mean model, logL are
#'    log likelihoods of full (H1) and reduced model (H0) respectively, converge
#'    is convergence status of numerical optimisation of model fitting by
#'    \code{optim} from \code{stats}. Each value matrix is called
#'    value_'condition' and has the form (genes x time points) and contains the
#'    counts predicted by the impulse model at the observed time points.
#' @param vecRefPval (vec length genes) Method 2 (DESeq2) adjusted p-values
#' @param strCaseName (str) Name of the case condition in \code{dfAnnotationProcFull}.
#' @param strControlName: (str) [Default NULL] Name of the control condition in 
#'    \code{dfAnnotationProcFull}.
#' @param strMode: (str) [Default "batch"] {"batch","longitudinal","singlecell"}
#'    Mode of model fitting.
#' @param NPARAM (scalar) [Default 6] Number of parameters of impulse model.
#' @param strFileNameSuffix (character string) [Default ""] File extention.
#' @param title_string (character string) [Default ""] Title for each plot.
#' @param strPlotSubtitle (character string) [Default ""] Subtitle for each plot.
#' 
#' @return NULL
#' @export

plotImputedGenes <- function(vecGeneIDs, 
  matCountDataProc,
  matCountDataImputed,
  matTranslationFactors=NULL, 
  matSizeFactors,
  dfAnnotationProc, 
  lsImpulseFits, 
  strCaseName, 
  strControlName=NULL, 
  strMode="batch",
  strFileNameSuffix = "", 
  strPlotTitleSuffix = "", 
  strPlotSubtitle = ""){ 
  
  # Process metadata
  vecConditions <- as.vector( dfAnnotationProc[match(
    colnames(matCountDataProc),
    dfAnnotationProc$Sample),
    ]$Condition )
  vecTimepointAssign <- as.vector( dfAnnotationProc[match(
    colnames(matCountDataProc),
    dfAnnotationProc$Sample),
    ]$Time )
  names(vecTimepointAssign) <- colnames(matCountDataProc)
  vecTimepoints <- sort(unique(vecTimepointAssign))
  if(!is.null(strControlName)){
    vecidxSamplesCase <- vecConditions %in% strCaseName
    vecidxSamplesCtrl <- vecConditions %in% strControlName
  }
  if(strMode=="longitudinal"){
    vecLongitudinalSeriesAssign <- dfAnnotationProc[match(
      colnames(matCountDataProc),
      dfAnnotationProc$Sample),
      ]$LongitudinalSeries
    vecLongitudinalSeries <- unique(vecLongitudinalSeriesAssign)
    vecindLongitudinalSeriesAssign <- match(vecLongitudinalSeriesAssign, vecLongitudinalSeries)
    vecindLongitudinalSeriesAssignUnique <- sapply(vecLongitudinalSeries,
      function(longser){min(which(vecLongitudinalSeriesAssign %in% longser))})
  }
  
  # Scale count data by size factors for plotting:
  # The impulse models are fit based on normalised means.
  # Therefore, the model curves follow the normalised
  # count data and not the raw count data. However, 
  # fitting was still performed based on raw count data.
  matCountDataProcNorm <- matCountDataProc / matSizeFactors
  matCountDataImputedNorm <- matCountDataImputed / matSizeFactors
  
  # Only for batch/singlecell plotting:
  # Width of negative binomial pdf (ylim) in time units for plotting
  # E.g. PDF_WIDTH <- 1 means that the inferred negative binomial
  # density of a sample will be scaled into the interval [0,1]
  # and plotted at sample x time units vertically in the interval
  # [x,x+1] time units, with the y axis (the counts) being the
  # horizontal axis of the pdf.
  PDF_WIDTH <- (max(vecTimepoints)-min(vecTimepoints))/10
  
  # Open .pdf
  pdf(paste("ImpulseDE2_",strFileNameSuffix,".pdf",sep=""),height=6.0,width=9.0)
  
  # Define grid for printing plots
  if (length(vecGeneIDs) == 1 | boolPlotOnePerPage){
    par(mfrow=c(1,1), xpd=TRUE)
    scaLegendInset <- -0.15
  } else if (length(vecGeneIDs) <= 4){
    par(mfrow=c(2,2), xpd=TRUE)
    scaLegendInset <- -0.35
  } else if (length(vecGeneIDs) <= 6){
    par(mfrow=c(2,3), xpd=TRUE)
    scaLegendInset <- -0.3
  } else {
    par(mfrow=c(3,3), xpd=TRUE)
    scaLegendInset <- -0.65
  }
  # Time points for plotting of impulse model
  vecX <- seq(min(vecTimepoints),max(vecTimepoints),min(0.1,(max(vecTimepoints)-min(vecTimepoints))/100))
  # Find elements in vecX corresponding (closest) to observed time point
  indVecXObs <- unlist(lapply( 
    vecTimepoints, function(t){match( min(abs(vecX-t)), abs(vecX-t) )} 
  ))
  for (geneID in vecGeneIDs){
    # Compute impulse model values
    # Convert h0,h1,h2 to log space again
    vecImpulseParamCaseLog <- lsImpulseFits$parameters_case[geneID,1:NPARAM]
    vecImpulseParamCaseLog[c("h0","h1","h2")] <- log( vecImpulseParamCaseLog[c("h0","h1","h2")] )
    vecCaseValues <- calcImpulse_comp(vecImpulseParamCaseLog,vecX)
    
    # Plot points, impulse trace and
    # batch: inferred negative binomials
    # longitudinal: longitudinal series scaled impulse traces
    if(strMode=="batch"){
      # Plot observed points in blue - all time courses in same colour
      scaYlim_lower <- min( min(matCountDataProcNorm[geneID,],na.rm=TRUE), min(vecCaseValues[indVecXObs]) )
      scaYlim_upper <- max( max(matCountDataProcNorm[geneID,],na.rm=TRUE), max(vecCaseValues[indVecXObs]) )
      if(max(vecCaseValues) > 2*max(matCountDataProcNorm[geneID,],na.rm=TRUE)){
        scaYlim_upper <- 2*max(matCountDataProcNorm[geneID,],na.rm=TRUE)
      }
      
      # Plot observed values
      plot(vecTimepointAssign,
        matCountDataProcNorm[geneID,],
        col="blue",
        pch=3,
        xlim=c(0,max(vecTimepoints,na.rm=TRUE)+PDF_WIDTH), 
        ylim=c(scaYlim_lower,scaYlim_upper),
        xlab="Time",
        ylab=paste0(strLogPlot," Impulse fit and count data"),
        main=paste0(geneID," ",strPlotTitleSuffix),sub=strPlotSubtitle)
      # Plot imputed values
      points(vecTimepointAssign,
        matCountDataImputedNorm[geneID,],
        col="red",
        pch=4)
      
      # Plot impulse model within boundaries of observed points
      vecCaseValuesToPlot <- vecCaseValues
      indImpulseValToPlot <- vecCaseValuesToPlot >= scaYlim_lower & vecCaseValuesToPlot <= scaYlim_upper
      vecCaseValuesToPlot[!indImpulseValToPlot] <- NA
      points(vecX, vecCaseValuesToPlot,col="black", type="l")
      
      legend(x="bottomright",
        legend=c("observed", "imputed"),
        fill=c("blue","red"), 
        cex=0.6, 
        inset=c(0,scaLegendInset))
      
    } else if(strMode=="longitudinal"){
      vecTranslationFactors <- matTranslationFactors[geneID,vecindLongitudinalSeriesAssignUnique]
      
      # Create colour vector
      vecCol <- rainbow(n=length(vecLongitudinalSeries))
      
      # Create plot and plot data of first time course
      scaYlim_lower <- min( min(matCountDataProcNorm[geneID,],na.rm=TRUE), 
        min(vecCaseValues[indVecXObs]*min(vecTranslationFactors)) )
      scaYlim_upper <- max( max(matCountDataProcNorm[geneID,],na.rm=TRUE), 
        max(vecCaseValues[indVecXObs]*max(vecTranslationFactors)) )
      if(max(vecCaseValues)*max(vecTranslationFactors) > 2*max(matCountDataProcNorm[geneID,],na.rm=TRUE)){
        scaYlim_upper <- 2*max(matCountDataProcNorm[geneID,],na.rm=TRUE)
      }

      # Plot observed values
      plot(vecTimepointAssign[vecindLongitudinalSeriesAssign==1],
        matCountDataProcNorm[geneID, vecindLongitudinalSeriesAssign==1],
        col=vecCol[1],pch=3,
        xlim=c(0,max(vecTimepoints,na.rm=TRUE)), 
        ylim=c(scaYlim_lower,scaYlim_upper),
        xlab="Time", ylab=paste0(strLogPlot," Impulse fit and count data"),
        main=paste0(geneID," ",strPlotTitleSuffix," log_10(Pval):\n ",strPvalImpulse,
          strPvalMethod2 ),sub=strPlotSubtitle)
      # Plot imputed values
      points(vecTimepointAssign,
        matCountDataImputedNorm[geneID, vecindLongitudinalSeriesAssign==1],
        col="black",
        pch=4)
      # Plot impulse fit to time course
      vecCaseValuesToPlotTC <- vecCaseValues*vecTranslationFactors[1]
      indImpulseValToPlot <- vecCaseValuesToPlotTC >= scaYlim_lower & vecCaseValuesToPlotTC <= scaYlim_upper
      vecCaseValuesToPlotTC[!indImpulseValToPlot] <- NA
      points(vecX, vecCaseValuesToPlotTC,col=vecCol[1], type="l")
      
      # Plot remaining time courses
      if(length(vecLongitudinalSeries)>1){
        for(longser in 2:length(vecLongitudinalSeries)){
          # Plot data of time course
          # Plot observed values
          points(x=vecTimepointAssign[vecindLongitudinalSeriesAssign==longser],
            y=matCountDataProcNorm[geneID, vecindLongitudinalSeriesAssign==longser],
            col=vecCol[longser],pch=3)
          # Plot imputed values
          points(vecTimepointAssign,
            matCountDataImputedNorm[geneID, vecindLongitudinalSeriesAssign==longser],
            col="black",
            pch=4)
          # Plot impulse within boundaries of observed points
          vecCaseValuesToPlotTC <- vecCaseValues*vecTranslationFactors[longser]
          indImpulseValToPlot <- vecCaseValuesToPlotTC >= scaYlim_lower & vecCaseValuesToPlotTC <= scaYlim_upper
          vecCaseValuesToPlotTC[!indImpulseValToPlot] <- NA
          points(vecX, 
            vecCaseValuesToPlotTC,
            col=vecCol[longser], type="l")
        }
      }
      
      legend(x="bottomright",
        legend=c(vecLongitudinalSeries, "imputed"),
        fill=c(vecCol,"black"), 
        cex=0.6, 
        inset=c(0,scaLegendInset-0.04*length(vecLongitudinalSeries)))
    } else {
      stop(paste0("ERROR: Unrecognised strMode in plotDEGenes(): ",strMode))  
    }
  }
  # Close .pdf
  dev.off()
}

#' Impute Samples in data set and analyse imputation
#'
#' This method is a wraper for imputation of observed samples:
#' Impulse models are trained on the data omitting one sample which
#' is then imputed based on inferred model and the imputation performance
#' is analysed based on the withheld data. Impulse training and imputation
#' are performed on all sub-data sets missing one sample. ImpulseDE2 must
#' be loaded for this.
#' Size factors are generated once on all data and kept constant throughout.
#' 
#' @seealso Auxillary method not called during ImpulseDE2 running.
#' Called separately by user.
#' 
#' @param matCountData: (matrix genes x samples) [Default NULL] 
#'    Count data of all conditions, unobserved entries are NA.
#' @param dfAnnotation: (Table) [Default NULL] 
#'    Lists co-variables of samples: 
#'    Sample, Condition, Time (numeric), (and Timecourse).
#' @param strCaseName: (str)
#'    Name of the case condition in \code{dfAnnotation}.
#' @param strControlName: (str) [Default NULL] 
#'    Name of the control condition in \code{dfAnnotation}.
#' @param strMode: (str) [Default "batch"] 
#'    {"batch","longitudinal"}
#'    Mode of model fitting. Don't use singlecell here.
#' @param nProc: (scalar) [Default 1] Number of processes for 
#'    parallelisation.
#' @parma dirTemp: (directory) Give directory for temporary
#'    data used for communicating translation factors.
#' 
#' @return matImputedSamplewise: (numeric matrix genes x samples)
#'    Imputed values based on values of drop-one-out impulse 
#'    models.
#' 
#' @export

runImputation <- function(matCountData,
  dfAnnotation,
  strCaseName,
  strControlName=NULL,
  strMode="batch",
  nProc=1,
  dirTemp){
  
  # 1. Process Input
  if(strMode=="singlecell"){
    stop("Don't use strMode==singlecell.")
  }
  scaNumGenes <- dim(matCountData)[1]
  scaNumSamples <- dim(matCountData)[2]
  
  # 2. Run imputation on all possible sub-data sets missing one sample:
  
  # Go to temporary directory
  tryCatch({
    setwd(dirTemp)
  }, error=function(strErrorMsg){
    stop(strErrorMsg)
  })
  
  # The first 3 steps of ImpulseDE2 have to be run
  # to generate the translation factors:
  print("1. Prepare data")
  lsProcessedData <- processData(
    dfAnnotation=dfAnnotation,
    matCountData=matCountData,
    scaSmallRun=NULL,
    strControlName=strControlName, 
    strCaseName=strCaseName,
    strMode=strMode,
    strSCMode=NULL,
    scaWindowRadius=NULL,
    lsPseudoDE=NULL,
    vecDispersionsExternal=NULL,
    vecSizeFactorsExternal=NULL,
    matTranslationFactorsExternal=NULL,
    boolRunDESeq2=TRUE )
  
  matCountDataProc <- lsProcessedData$matCountDataProc
  matCountDataProcFull <- lsProcessedData$matCountDataProcFull
  dfAnnotationProc <- lsProcessedData$dfAnnotationProc
  matProbNB <- lsProcessedData$matProbNB
  matDropoutRate <- lsProcessedData$matDropout
  vecClusterAssignments <- lsProcessedData$vecClusterAssignments
  vecCentroids <- lsProcessedData$vecCentroids
  
  print("2. Run DESeq2")
  lsDESeq2Results <- runDESeq2(
    dfAnnotationProc=dfAnnotationProc,
    matCountDataProc=matCountDataProcFull,
    nProc=nProc,
    strCaseName=strCaseName,
    strControlName=strControlName,
    strMode=strMode)
  vecDispersions <- (lsDESeq2Results$vecDispersions)[rownames(matCountDataProc)]
  
  # Generate scaling factors (need for imputation):
  # Note that all models are created and evaluated under the same
  # scaling factors fit to the entire data set. The rationale behind
  # this is that a de novo imputation does not assume any scaling effects.
  # Therefore, if an imputation is evaluated with given data, it
  # has to be evaluated taking the scaling factors into consideration.
  # These are functions from ImpulseDE2
  # - Generate size factors
  matSizeFactors <- computeSizeFactors(matCountDataProc=matCountData,
    scaSmallRun=NULL,
    strMode=strMode)
  vecSizeFactors <- matSizeFactors[1,]
  if(strMode=="longitudinal"){
    print("3. Compute translation factors")
    matTranslationFactors <- computeTranslationFactors(
      matCountDataProc=matCountData,
      matSizeFactors=matSizeFactors,
      vecDispersions,
      scaSmallRun=NULL,
      dfAnnotationProc=dfAnnotationProc,
      strCaseName=strCaseName,
      strControlName=strControlName)
    colnames(matTranslationFactors) <- colnames(matCountData)
  }
  
  # Sample wise imputation
  matImputedSamplewise <- matrix(NA, nrow=scaNumGenes, ncol=scaNumSamples)
  for(sample in seq(1,scaNumSamples)){
    print(paste0("Imputation ", sample, " out of ", scaNumSamples))
    print(paste0("Training impulse model..."))
    # Set vector of indices of samples to used
    if(sample==1){
      vecTrainSamples <- seq(2,scaNumSamples)
    } else if(sample==scaNumSamples){
      vecTrainSamples <- seq(1,scaNumSamples-1)
    } else {
      vecTrainSamples <- c(seq(1,sample-1),seq(sample+1),scaNumSamples)
    }
    strWithheldSample <- (colnames(matCountData))[sample]
    matCountDataMissing <- matCountData[,vecTrainSamples]
    if(strMode=="batch"){
      matTranslationFactorsExternal <- NULL
    } else if(strMode=="longitudinal"){
      matTranslationFactorsExternal <- matTranslationFactors[,vecTrainSamples]
    } else {
      stop("strMode not recognised in runImputation")
    }
    lsImpulseDE_results <- runImpulseDE2(
      matCountData=matCountData[,vecTrainSamples], 
      dfAnnotation=dfAnnotation[dfAnnotation$Sample!=strWithheldSample,],
      strCaseName = strCaseName, 
      strControlName=strControlName, 
      strMode=strMode,
      nProc=nProc,
      Q_value=10^(-2),
      vecSizeFactorsExternal=vecSizeFactors[vecTrainSamples],
      matTranslationFactorsExternal=matTranslationFactorsExternal,
      boolPlotting=FALSE,
      scaSmallRun=NULL,
      boolSaveTemp=FALSE)
    save(lsImpulseDE_results,file=file.path(getwd(),paste0("ImpulseDE2_Impute_lsImpulseDE_results_Sample",sample,".RData")))
    
    print(paste0("Imputing data..."))
    # a) Generate raw model imputation
    vecImputedSample <- as.vector( sapply(seq(1,scaNumSamples), function(sample){
      imputeSamples(dirTemp=NULL,
        vecTPtoImpute=as.numeric(dfAnnotation[dfAnnotation$Sample==strWithheldSample,"Time"]),
        strCaseName=NULL,
        strCtrlName=NULL,
        matModel=lsImpulseDE_results$lsImpulseFits$parameters_case)
    }))
    # b) Correct for size factor
    vecImputedSample <- vecImputedSample*vecSizeFactors[sample]
    # c) Correct for longitudinal series
    if(strMode=="longitudinal"){
      # This code uses non-standardised translation factors: discouraged
      # Need translation factors for imputation in longitudinal mode
      #load("ImpulseDE2_matTranslationFactors.Rdata")
      # Get longitudinal series to which withheld corresponds
      #strLongser <- dfAnnotation[dfAnnotation$Sample==strWithheldSample,"LongitudinalSeries"]
      # Get a non-withheld sample from the given longitudinal series
      #strLongserSample <- (dfAnnotation[dfAnnotation$LongitudinalSeries==strLongser,"Sample"])[1]
      # Get translation factors corresponding to longitudinal serie:
      # Note translation factors are the same for a longitudinal series given a gene.
      #vecTranslationFactors <- matTranslationFactors[,strLongserSample]
      #vecImputedSample <- vecImputedSample*vecTranslationFactors
      
      vecImputedSample <- vecImputedSample*matTranslationFactors[,sample]
    }
    matImputedSamplewise[,sample] <- vecImputedSample
  }
  save(matImputedSamplewise,file=file.path(getwd(),"ImpulseDE2_Impute_matImputedSamplewise.RData"))
  
  # Baseline imputation:
  # Impute as average of neighbours (or as neighbour on ends).
  matImputedBaseline <- matrix(NA, nrow=scaNumGenes, ncol=scaNumSamples)
  matImputedBaseline[,1] = matCountData[,2]
  for(sample in seq(2,scaNumSamples-1)){
    matImputedBaseline[,sample] <- (matImputedBaseline[,sample-1]+
        matImputedBaseline[,sample+1])/2
  }
  matImputedBaseline[,scaNumSamples] = matCountData[,scaNumSamples-1]
  save(matImputedBaseline,file=file.path(getwd(),"ImpulseDE2_Impute_matImputedBaseline.RData"))
  
  # Generate imputation error statistics:
  # Overall deviation comparison: LRT
  # Compute loglikelihood of impulse imputed
  matLLImpulseImputed <- dnbinom(x=matImputedSamplewise,
    mu=matCountData,
    size=matrix(vecDispersions,
      nrow=dim(matCountData)[1],
      ncol=dim(matCountData)[2],
      byrow=FALSE),
    log=TRUE)
  vecLLImpulseImputedByGene <- apply(matLLImpulseImputed, 1, 
    function(gene) sum(gene, na.rm=TRUE))
  # Compute loglikelihood of baseline imputed
  matLLBaselineImputed <- dnbinom(x=matImputedBaseline,
    mu=matCountData,
    size=matrix(vecDispersions,
      nrow=dim(matCountData)[1],
      ncol=dim(matCountData)[2],
      byrow=FALSE),
    log=TRUE)
  vecLLBaselineImputedByGene <- apply(matLLBaselineImputed, 1, 
    function(gene) sum(gene, na.rm=TRUE))
  # LRT
  vecLRT <- vecLLImpulseImputedByGene-vecLLBaselineImputedByGene
  hist(vecLRT)
  
  # Look at absolute deviations
  matAbsDevImpulseImputed <- abs(matCountData-matImputedSamplewise)
  matAbsDevBaselineImputed <- abs(matCountData-matImputedBaseline)
  # Plot histograms
  matAbsDevImpulseImputedMolten <- melt(matAbsDevImpulseImputed)
  matAbsDevImpulseImputedMolten$type <- "impulse"
  matAbsDevBaselineImputedMolten <- melt(matAbsDevBaselineImputed)
  matAbsDevBaselineImputedMolten$type <- "baseline"
  dfAbsDev <- rbind(
    matAbsDevImpulseImputedMolten,
    matAbsDevBaselineImputedMolten )
  gHistAbsDev <- ggplot( dfAbsDev, aes(value, fill = type)) +
  	geom_histogram(alpha = 0.5, aes(y = ..density..), position = 'identity') +
		ggtitle(paste0("Absolute deviation imputed from observed")) +
		xlab("Absolute deviation") +
		ylab("Density")
  print(gHistAbsDev)
  
  # Plot data
  plotImputedGenes(vecGeneIDs, 
    matCountDataProc=matCountData,
    matCountDataImputed=matImputedSamplewise,
    matTranslationFactors=matTranslationFactorsExternal, 
    matSizeFactors=matSizeFactors,
    dfAnnotationProc=dfAnnotation, 
    lsImpulseFits=lsImpulseDE_results$lsImpulseFits, 
    strCaseName=strCaseName, 
    strControlName=NULL, 
    strMode=strMode,
    strFileNameSuffix = "", 
    strPlotTitleSuffix = "", 
    strPlotSubtitle = "")
  
  return(matImputedSamplewise)
}